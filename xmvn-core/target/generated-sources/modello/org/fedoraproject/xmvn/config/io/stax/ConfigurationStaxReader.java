// =================== DO NOT EDIT THIS FILE ====================
// Generated by Modello 1.8.2,
// any modifications will be overwritten.
// ==============================================================

package org.fedoraproject.xmvn.config.io.stax;

  //---------------------------------/
 //- Imported classes and packages -/
//---------------------------------/

import java.io.ByteArrayInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
import java.text.DateFormat;
import java.text.ParsePosition;
import java.util.Locale;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.xml.stream.*;
import org.codehaus.plexus.util.xml.Xpp3Dom;
import org.fedoraproject.xmvn.config.Artifact;
import org.fedoraproject.xmvn.config.BuildSettings;
import org.fedoraproject.xmvn.config.Configuration;
import org.fedoraproject.xmvn.config.InstallerSettings;
import org.fedoraproject.xmvn.config.PackagingRule;
import org.fedoraproject.xmvn.config.Repository;
import org.fedoraproject.xmvn.config.ResolverSettings;
import org.fedoraproject.xmvn.config.Stereotype;

/**
 * Class ConfigurationStaxReader.
 * 
 * @version $Revision$ $Date$
 */
@SuppressWarnings( "all" )
public class ConfigurationStaxReader
{

      //-----------/
     //- Methods -/
    //-----------/

    /**
     * Method read.
     * 
     * @param reader
     * @param strict
     * @throws IOException
     * @throws XMLStreamException
     * @return Configuration
     */
    public Configuration read( Reader reader, boolean strict )
        throws IOException, XMLStreamException
    {
        XMLStreamReader xmlStreamReader = XMLInputFactory.newInstance().createXMLStreamReader( reader );

        return read( xmlStreamReader, strict );
    } //-- Configuration read( Reader, boolean )

    /**
     * Method read.
     * 
     * @param reader
     * @throws IOException
     * @throws XMLStreamException
     * @return Configuration
     */
    public Configuration read( Reader reader )
        throws IOException, XMLStreamException
    {
        return read( reader, true );
    } //-- Configuration read( Reader )

    /**
     * Method read.
     * 
     * @param stream
     * @param strict
     * @throws IOException
     * @throws XMLStreamException
     * @return Configuration
     */
    public Configuration read( InputStream stream, boolean strict )
        throws IOException, XMLStreamException
    {
        XMLStreamReader xmlStreamReader = XMLInputFactory.newInstance().createXMLStreamReader( stream );

        return read( xmlStreamReader, strict );
    } //-- Configuration read( InputStream, boolean )

    /**
     * Method read.
     * 
     * @param stream
     * @throws IOException
     * @throws XMLStreamException
     * @return Configuration
     */
    public Configuration read( InputStream stream )
        throws IOException, XMLStreamException
    {
        return read( stream, true );
    } //-- Configuration read( InputStream )

    /**
     * Method read.
     * 
     * @param filePath
     * @param strict
     * @throws IOException
     * @throws XMLStreamException
     * @return Configuration
     */
    public Configuration read( String filePath, boolean strict )
        throws IOException, XMLStreamException
    {
        java.io.File file = new java.io.File( filePath );
        XMLStreamReader xmlStreamReader = XMLInputFactory.newInstance().createXMLStreamReader( file.toURI().toURL().toExternalForm(), new FileInputStream( file ) );

        return read( xmlStreamReader, strict );
    } //-- Configuration read( String, boolean )

    /**
     * Method read.
     * 
     * @param filePath
     * @throws IOException
     * @throws XMLStreamException
     * @return Configuration
     */
    public Configuration read( String filePath )
        throws IOException, XMLStreamException
    {
        return read( filePath, true );
    } //-- Configuration read( String )

    /**
     * Method buildDom.
     * 
     * @param xmlStreamReader
     * @param trim
     * @throws XMLStreamException
     * @return Xpp3Dom
     */
    private Xpp3Dom buildDom( XMLStreamReader xmlStreamReader, boolean trim )
        throws XMLStreamException
    {
        java.util.Stack elements = new java.util.Stack();
        java.util.Stack values = new java.util.Stack();
        int eventType = xmlStreamReader.getEventType();
        boolean spacePreserve = false;
        while ( xmlStreamReader.hasNext() )
        {
            if ( eventType == XMLStreamConstants.START_ELEMENT )
            {
                spacePreserve = false;
                String rawName = xmlStreamReader.getLocalName();
                Xpp3Dom element = new Xpp3Dom( rawName );
                if ( !elements.empty() )
                {
                    Xpp3Dom parent = (Xpp3Dom) elements.peek();
                    parent.addChild( element );
                }
                elements.push( element );
                if ( xmlStreamReader.isEndElement() )
                {
                    values.push( null );
                }
                else
                {
                    values.push( new StringBuffer() );
                }
                int attributesSize = xmlStreamReader.getAttributeCount();
                for ( int i = 0; i < attributesSize; i++ )
                {
                    String name = xmlStreamReader.getAttributeLocalName( i );
                    String value = xmlStreamReader.getAttributeValue( i );
                    element.setAttribute( name, value );
                    spacePreserve = spacePreserve || ( "xml".equals( xmlStreamReader.getAttributePrefix( i ) ) && "space".equals( name ) && "preserve".equals( value ) );
                }
            }
            else if ( eventType == XMLStreamConstants.CHARACTERS )
            {
                StringBuffer valueBuffer = (StringBuffer) values.peek();
                String text = xmlStreamReader.getText();
                if ( trim && !spacePreserve )
                {
                    text = text.trim();
                }
                valueBuffer.append( text );
            }
            else if ( eventType == XMLStreamConstants.END_ELEMENT )
            {
                Xpp3Dom element = (Xpp3Dom) elements.pop();
                // this Object could be null if it is a singleton tag
                Object accumulatedValue = values.pop();
                if ( element.getChildCount() == 0 )
                {
                    element.setValue( ( accumulatedValue == null ) ? null : accumulatedValue.toString() );
                }
                if ( values.empty() )
                {
                    return element;
                }
            }
            eventType = xmlStreamReader.next();
        }
        throw new IllegalStateException( "End of document found before returning to 0 depth" );
    } //-- Xpp3Dom buildDom( XMLStreamReader, boolean )

    /**
     * Method checkFieldWithDuplicate.
     * 
     * @param xmlStreamReader
     * @param parsed
     * @param alias
     * @param tagName
     * @throws XMLStreamException
     * @return boolean
     */
    private boolean checkFieldWithDuplicate( XMLStreamReader xmlStreamReader, String tagName, String alias, java.util.Set parsed )
        throws XMLStreamException
    {
        if ( !( xmlStreamReader.getLocalName().equals( tagName ) || xmlStreamReader.getLocalName().equals( alias ) ) )
        {
            return false;
        }
        if ( !parsed.add( tagName ) )
        {
            throw new XMLStreamException( "Duplicated tag: '" + tagName + "'", xmlStreamReader.getLocation() );
        }
        return true;
    } //-- boolean checkFieldWithDuplicate( XMLStreamReader, String, String, java.util.Set )

    /**
     * Method checkUnknownElement.
     * 
     * @param xmlStreamReader
     * @param strict
     * @throws XMLStreamException
     */
    private void checkUnknownElement( XMLStreamReader xmlStreamReader, boolean strict )
        throws XMLStreamException
    {
        if ( strict )
        {
            throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
        }
        int unrecognizedTagCount = 1;
        while( unrecognizedTagCount != 0 )
        {
            xmlStreamReader.next();
            if ( xmlStreamReader.getEventType() == XMLStreamConstants.START_ELEMENT )
            {
                unrecognizedTagCount++;
            }
            else if ( xmlStreamReader.getEventType() == XMLStreamConstants.END_ELEMENT )
            {
                unrecognizedTagCount--;
            }
        }
    } //-- void checkUnknownElement( XMLStreamReader, boolean )

    /**
     * Method getBooleanValue.
     * 
     * @param s
     * @param xmlStreamReader
     * @param attribute
     * @throws XMLStreamException
     * @return boolean
     */
    private boolean getBooleanValue( String s, String attribute, XMLStreamReader xmlStreamReader )
        throws XMLStreamException
    {
        if ( s != null )
        {
            return Boolean.valueOf( s ).booleanValue();
        }
        return false;
    } //-- boolean getBooleanValue( String, String, XMLStreamReader )

    /**
     * Method getByteValue.
     * 
     * @param s
     * @param strict
     * @param xmlStreamReader
     * @param attribute
     * @throws XMLStreamException
     * @return byte
     */
    private byte getByteValue( String s, String attribute, XMLStreamReader xmlStreamReader, boolean strict )
        throws XMLStreamException
    {
        if ( s != null )
        {
            try
            {
                return Byte.valueOf( s ).byteValue();
            }
            catch ( NumberFormatException nfe )
            {
                if ( strict )
                {
                    throw new XMLStreamException( "Unable to parse element '" + attribute + "', must be a byte but was '" + s + "'", xmlStreamReader.getLocation(), nfe );
                }
            }
        }
        return 0;
    } //-- byte getByteValue( String, String, XMLStreamReader, boolean )

    /**
     * Method getCharacterValue.
     * 
     * @param s
     * @param xmlStreamReader
     * @param attribute
     * @throws XMLStreamException
     * @return char
     */
    private char getCharacterValue( String s, String attribute, XMLStreamReader xmlStreamReader )
        throws XMLStreamException
    {
        if ( s != null )
        {
            return s.charAt( 0 );
        }
        return 0;
    } //-- char getCharacterValue( String, String, XMLStreamReader )

    /**
     * Method getDateValue.
     * 
     * @param s
     * @param xmlStreamReader
     * @param dateFormat
     * @param attribute
     * @throws XMLStreamException
     * @return Date
     */
    private java.util.Date getDateValue( String s, String attribute, String dateFormat, XMLStreamReader xmlStreamReader )
        throws XMLStreamException
    {
        if ( s != null )
        {
            String effectiveDateFormat = dateFormat;
            if ( dateFormat == null )
            {
                effectiveDateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSS";
            }
            if ( "long".equals( effectiveDateFormat ) )
            {
                try
                {
                    return new java.util.Date( Long.parseLong( s ) );
                }
                catch ( NumberFormatException e )
                {
                    throw new XMLStreamException( e.getMessage(), xmlStreamReader.getLocation(), e );
                }
            }
            else
            {
                try
                {
                    DateFormat dateParser = new java.text.SimpleDateFormat( effectiveDateFormat, java.util.Locale.US );
                    return dateParser.parse( s );
                }
                catch ( java.text.ParseException e )
                {
                    throw new XMLStreamException( e.getMessage(), xmlStreamReader.getLocation(), e );
                }
            }
        }
        return null;
    } //-- java.util.Date getDateValue( String, String, String, XMLStreamReader )

    /**
     * Method getDefaultValue.
     * 
     * @param s
     * @param v
     * @return String
     */
    private String getDefaultValue( String s, String v )
    {
        if ( s == null )
        {
            s = v;
        }
        return s;
    } //-- String getDefaultValue( String, String )

    /**
     * Method getDoubleValue.
     * 
     * @param s
     * @param strict
     * @param xmlStreamReader
     * @param attribute
     * @throws XMLStreamException
     * @return double
     */
    private double getDoubleValue( String s, String attribute, XMLStreamReader xmlStreamReader, boolean strict )
        throws XMLStreamException
    {
        if ( s != null )
        {
            try
            {
                return Double.valueOf( s ).doubleValue();
            }
            catch ( NumberFormatException nfe )
            {
                if ( strict )
                {
                    throw new XMLStreamException( "Unable to parse element '" + attribute + "', must be a floating point number but was '" + s + "'", xmlStreamReader.getLocation(), nfe );
                }
            }
        }
        return 0;
    } //-- double getDoubleValue( String, String, XMLStreamReader, boolean )

    /**
     * Method getFloatValue.
     * 
     * @param s
     * @param strict
     * @param xmlStreamReader
     * @param attribute
     * @throws XMLStreamException
     * @return float
     */
    private float getFloatValue( String s, String attribute, XMLStreamReader xmlStreamReader, boolean strict )
        throws XMLStreamException
    {
        if ( s != null )
        {
            try
            {
                return Float.valueOf( s ).floatValue();
            }
            catch ( NumberFormatException nfe )
            {
                if ( strict )
                {
                    throw new XMLStreamException( "Unable to parse element '" + attribute + "', must be a floating point number but was '" + s + "'", xmlStreamReader.getLocation(), nfe );
                }
            }
        }
        return 0;
    } //-- float getFloatValue( String, String, XMLStreamReader, boolean )

    /**
     * Method getIntegerValue.
     * 
     * @param s
     * @param strict
     * @param xmlStreamReader
     * @param attribute
     * @throws XMLStreamException
     * @return int
     */
    private int getIntegerValue( String s, String attribute, XMLStreamReader xmlStreamReader, boolean strict )
        throws XMLStreamException
    {
        if ( s != null )
        {
            try
            {
                return Integer.valueOf( s ).intValue();
            }
            catch ( NumberFormatException nfe )
            {
                if ( strict )
                {
                    throw new XMLStreamException( "Unable to parse element '" + attribute + "', must be an integer but was '" + s + "'", xmlStreamReader.getLocation(), nfe );
                }
            }
        }
        return 0;
    } //-- int getIntegerValue( String, String, XMLStreamReader, boolean )

    /**
     * Method getLongValue.
     * 
     * @param s
     * @param strict
     * @param xmlStreamReader
     * @param attribute
     * @throws XMLStreamException
     * @return long
     */
    private long getLongValue( String s, String attribute, XMLStreamReader xmlStreamReader, boolean strict )
        throws XMLStreamException
    {
        if ( s != null )
        {
            try
            {
                return Long.valueOf( s ).longValue();
            }
            catch ( NumberFormatException nfe )
            {
                if ( strict )
                {
                    throw new XMLStreamException( "Unable to parse element '" + attribute + "', must be a long integer but was '" + s + "'", xmlStreamReader.getLocation(), nfe );
                }
            }
        }
        return 0;
    } //-- long getLongValue( String, String, XMLStreamReader, boolean )

    /**
     * Method getRequiredAttributeValue.
     * 
     * @param s
     * @param strict
     * @param xmlStreamReader
     * @param attribute
     * @throws XMLStreamException
     * @return String
     */
    private String getRequiredAttributeValue( String s, String attribute, XMLStreamReader xmlStreamReader, boolean strict )
        throws XMLStreamException
    {
        if ( s == null )
        {
            if ( strict )
            {
                throw new XMLStreamException( "Missing required value for attribute '" + attribute + "'", xmlStreamReader.getLocation() );
            }
        }
        return s;
    } //-- String getRequiredAttributeValue( String, String, XMLStreamReader, boolean )

    /**
     * Method getShortValue.
     * 
     * @param s
     * @param strict
     * @param xmlStreamReader
     * @param attribute
     * @throws XMLStreamException
     * @return short
     */
    private short getShortValue( String s, String attribute, XMLStreamReader xmlStreamReader, boolean strict )
        throws XMLStreamException
    {
        if ( s != null )
        {
            try
            {
                return Short.valueOf( s ).shortValue();
            }
            catch ( NumberFormatException nfe )
            {
                if ( strict )
                {
                    throw new XMLStreamException( "Unable to parse element '" + attribute + "', must be a short integer but was '" + s + "'", xmlStreamReader.getLocation(), nfe );
                }
            }
        }
        return 0;
    } //-- short getShortValue( String, String, XMLStreamReader, boolean )

    /**
     * Method getTrimmedValue.
     * 
     * @param s
     * @return String
     */
    private String getTrimmedValue( String s )
    {
        if ( s != null )
        {
            s = s.trim();
        }
        return s;
    } //-- String getTrimmedValue( String )

    /**
     * Method nextTag.
     * 
     * @param xmlStreamReader
     * @throws XMLStreamException
     * @return int
     */
    private int nextTag( XMLStreamReader xmlStreamReader )
        throws XMLStreamException
    {
        while ( true )
        {
            int eventType = xmlStreamReader.next();
            switch ( eventType )
            {
                case XMLStreamConstants.CHARACTERS:
                case XMLStreamConstants.CDATA:
                case XMLStreamConstants.SPACE:
                case XMLStreamConstants.PROCESSING_INSTRUCTION:
                case XMLStreamConstants.COMMENT:
                    break;
                case XMLStreamConstants.START_ELEMENT:
                case XMLStreamConstants.END_ELEMENT:
                    return eventType;
                default:
                    throw new XMLStreamException( "expected start or end tag", xmlStreamReader.getLocation() );
            }
        }
    } //-- int nextTag( XMLStreamReader )

    /**
     * Method parseArtifact.
     * 
     * @param xmlStreamReader
     * @param strict
     * @throws IOException
     * @throws XMLStreamException
     * @return Artifact
     */
    private Artifact parseArtifact( XMLStreamReader xmlStreamReader, boolean strict )
        throws IOException, XMLStreamException
    {
        Artifact artifact = new Artifact();
        java.util.Set parsed = new java.util.HashSet();
        while ( ( strict ? xmlStreamReader.nextTag() : nextTag( xmlStreamReader ) ) == XMLStreamConstants.START_ELEMENT )
        {
            if ( checkFieldWithDuplicate( xmlStreamReader, "groupId", null, parsed ) )
            {
                artifact.setGroupId( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "" ) ) );
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "artifactId", null, parsed ) )
            {
                artifact.setArtifactId( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "" ) ) );
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "version", null, parsed ) )
            {
                artifact.setVersion( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "" ) ) );
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "classifier", null, parsed ) )
            {
                artifact.setClassifier( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "" ) ) );
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "stereotype", null, parsed ) )
            {
                artifact.setStereotype( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "" ) ) );
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "extension", null, parsed ) )
            {
                artifact.setExtension( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "" ) ) );
            }
            else
            {
                checkUnknownElement( xmlStreamReader, strict );
            }
        }
        return artifact;
    } //-- Artifact parseArtifact( XMLStreamReader, boolean )

    /**
     * Method parseBuildSettings.
     * 
     * @param xmlStreamReader
     * @param strict
     * @throws IOException
     * @throws XMLStreamException
     * @return BuildSettings
     */
    private BuildSettings parseBuildSettings( XMLStreamReader xmlStreamReader, boolean strict )
        throws IOException, XMLStreamException
    {
        BuildSettings buildSettings = new BuildSettings();
        java.util.Set parsed = new java.util.HashSet();
        while ( ( strict ? xmlStreamReader.nextTag() : nextTag( xmlStreamReader ) ) == XMLStreamConstants.START_ELEMENT )
        {
            if ( checkFieldWithDuplicate( xmlStreamReader, "debug", null, parsed ) )
            {
                buildSettings.setDebug( getBooleanValue( getTrimmedValue( xmlStreamReader.getElementText() ), "debug", xmlStreamReader ) );
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "skipTests", null, parsed ) )
            {
                buildSettings.setSkipTests( getBooleanValue( getTrimmedValue( xmlStreamReader.getElementText() ), "skipTests", xmlStreamReader ) );
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "compilerSource", null, parsed ) )
            {
                buildSettings.setCompilerSource( getTrimmedValue( xmlStreamReader.getElementText() ) );
            }
            else
            {
                checkUnknownElement( xmlStreamReader, strict );
            }
        }
        return buildSettings;
    } //-- BuildSettings parseBuildSettings( XMLStreamReader, boolean )

    /**
     * Method parseConfiguration.
     * 
     * @param xmlStreamReader
     * @param strict
     * @throws IOException
     * @throws XMLStreamException
     * @return Configuration
     */
    private Configuration parseConfiguration( XMLStreamReader xmlStreamReader, boolean strict )
        throws IOException, XMLStreamException
    {
        Configuration configuration = new Configuration();
        java.util.Set parsed = new java.util.HashSet();
        while ( ( strict ? xmlStreamReader.nextTag() : nextTag( xmlStreamReader ) ) == XMLStreamConstants.START_ELEMENT )
        {
            if ( checkFieldWithDuplicate( xmlStreamReader, "properties", null, parsed ) )
            {
                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
                {
                    String key = xmlStreamReader.getLocalName();
                    String value = xmlStreamReader.getElementText().trim();
                    configuration.addProperty( key, value );
                }
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "repositories", null, parsed ) )
            {
                java.util.List repositories = new java.util.ArrayList/*<Repository>*/();
                configuration.setRepositories( repositories );
                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
                {
                    if ( "repository".equals( xmlStreamReader.getLocalName() ) )
                    {
                        configuration.addRepository( parseRepository( xmlStreamReader, strict ) );
                    }
                    else
                    {
                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
                    }
                }
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "buildSettings", null, parsed ) )
            {
                configuration.setBuildSettings( parseBuildSettings( xmlStreamReader, strict ) );
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "artifactManagement", null, parsed ) )
            {
                java.util.List artifactManagement = new java.util.ArrayList/*<PackagingRule>*/();
                configuration.setArtifactManagement( artifactManagement );
                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
                {
                    if ( "rule".equals( xmlStreamReader.getLocalName() ) )
                    {
                        configuration.addArtifactManagement( parsePackagingRule( xmlStreamReader, strict ) );
                    }
                    else
                    {
                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
                    }
                }
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "resolverSettings", null, parsed ) )
            {
                configuration.setResolverSettings( parseResolverSettings( xmlStreamReader, strict ) );
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "installerSettings", null, parsed ) )
            {
                configuration.setInstallerSettings( parseInstallerSettings( xmlStreamReader, strict ) );
            }
            else
            {
                checkUnknownElement( xmlStreamReader, strict );
            }
        }
        return configuration;
    } //-- Configuration parseConfiguration( XMLStreamReader, boolean )

    /**
     * Method parseInstallerSettings.
     * 
     * @param xmlStreamReader
     * @param strict
     * @throws IOException
     * @throws XMLStreamException
     * @return InstallerSettings
     */
    private InstallerSettings parseInstallerSettings( XMLStreamReader xmlStreamReader, boolean strict )
        throws IOException, XMLStreamException
    {
        InstallerSettings installerSettings = new InstallerSettings();
        java.util.Set parsed = new java.util.HashSet();
        while ( ( strict ? xmlStreamReader.nextTag() : nextTag( xmlStreamReader ) ) == XMLStreamConstants.START_ELEMENT )
        {
            if ( checkFieldWithDuplicate( xmlStreamReader, "debug", null, parsed ) )
            {
                installerSettings.setDebug( getBooleanValue( getTrimmedValue( xmlStreamReader.getElementText() ), "debug", xmlStreamReader ) );
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "metadataDir", null, parsed ) )
            {
                installerSettings.setMetadataDir( getTrimmedValue( xmlStreamReader.getElementText() ) );
            }
            else
            {
                checkUnknownElement( xmlStreamReader, strict );
            }
        }
        return installerSettings;
    } //-- InstallerSettings parseInstallerSettings( XMLStreamReader, boolean )

    /**
     * Method parsePackagingRule.
     * 
     * @param xmlStreamReader
     * @param strict
     * @throws IOException
     * @throws XMLStreamException
     * @return PackagingRule
     */
    private PackagingRule parsePackagingRule( XMLStreamReader xmlStreamReader, boolean strict )
        throws IOException, XMLStreamException
    {
        PackagingRule packagingRule = new PackagingRule();
        java.util.Set parsed = new java.util.HashSet();
        while ( ( strict ? xmlStreamReader.nextTag() : nextTag( xmlStreamReader ) ) == XMLStreamConstants.START_ELEMENT )
        {
            if ( checkFieldWithDuplicate( xmlStreamReader, "artifactGlob", null, parsed ) )
            {
                packagingRule.setArtifactGlob( parseArtifact( xmlStreamReader, strict ) );
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "targetPackage", null, parsed ) )
            {
                packagingRule.setTargetPackage( getTrimmedValue( xmlStreamReader.getElementText() ) );
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "targetRepository", null, parsed ) )
            {
                packagingRule.setTargetRepository( getTrimmedValue( xmlStreamReader.getElementText() ) );
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "files", null, parsed ) )
            {
                java.util.List files = new java.util.ArrayList/*<String>*/();
                packagingRule.setFiles( files );
                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
                {
                    if ( "file".equals( xmlStreamReader.getLocalName() ) )
                    {
                        files.add( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "new java.util.ArrayList/*<String>*/()" ) ) );
                    }
                    else
                    {
                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
                    }
                }
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "versions", null, parsed ) )
            {
                java.util.List versions = new java.util.ArrayList/*<String>*/();
                packagingRule.setVersions( versions );
                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
                {
                    if ( "version".equals( xmlStreamReader.getLocalName() ) )
                    {
                        versions.add( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "new java.util.ArrayList/*<String>*/()" ) ) );
                    }
                    else
                    {
                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
                    }
                }
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "aliases", null, parsed ) )
            {
                java.util.List aliases = new java.util.ArrayList/*<Artifact>*/();
                packagingRule.setAliases( aliases );
                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
                {
                    if ( "alias".equals( xmlStreamReader.getLocalName() ) )
                    {
                        aliases.add( parseArtifact( xmlStreamReader, strict ) );
                    }
                    else
                    {
                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
                    }
                }
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "optional", null, parsed ) )
            {
                packagingRule.setOptional( getBooleanValue( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "false" ) ), "optional", xmlStreamReader ) );
            }
            else
            {
                checkUnknownElement( xmlStreamReader, strict );
            }
        }
        return packagingRule;
    } //-- PackagingRule parsePackagingRule( XMLStreamReader, boolean )

    /**
     * Method parseRepository.
     * 
     * @param xmlStreamReader
     * @param strict
     * @throws IOException
     * @throws XMLStreamException
     * @return Repository
     */
    private Repository parseRepository( XMLStreamReader xmlStreamReader, boolean strict )
        throws IOException, XMLStreamException
    {
        Repository repository = new Repository();
        java.util.Set parsed = new java.util.HashSet();
        while ( ( strict ? xmlStreamReader.nextTag() : nextTag( xmlStreamReader ) ) == XMLStreamConstants.START_ELEMENT )
        {
            if ( checkFieldWithDuplicate( xmlStreamReader, "id", null, parsed ) )
            {
                repository.setId( getTrimmedValue( xmlStreamReader.getElementText() ) );
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "type", null, parsed ) )
            {
                repository.setType( getTrimmedValue( xmlStreamReader.getElementText() ) );
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "stereotypes", null, parsed ) )
            {
                java.util.List stereotypes = new java.util.ArrayList/*<Stereotype>*/();
                repository.setStereotypes( stereotypes );
                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
                {
                    if ( "stereotype".equals( xmlStreamReader.getLocalName() ) )
                    {
                        repository.addStereotype( parseStereotype( xmlStreamReader, strict ) );
                    }
                    else
                    {
                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
                    }
                }
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "properties", null, parsed ) )
            {
                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
                {
                    String key = xmlStreamReader.getLocalName();
                    String value = xmlStreamReader.getElementText().trim();
                    repository.addProperty( key, value );
                }
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "configuration", null, parsed ) )
            {
                repository.setConfiguration( buildDom( xmlStreamReader, true ) );
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "filter", null, parsed ) )
            {
                repository.setFilter( buildDom( xmlStreamReader, true ) );
            }
            else
            {
                checkUnknownElement( xmlStreamReader, strict );
            }
        }
        return repository;
    } //-- Repository parseRepository( XMLStreamReader, boolean )

    /**
     * Method parseResolverSettings.
     * 
     * @param xmlStreamReader
     * @param strict
     * @throws IOException
     * @throws XMLStreamException
     * @return ResolverSettings
     */
    private ResolverSettings parseResolverSettings( XMLStreamReader xmlStreamReader, boolean strict )
        throws IOException, XMLStreamException
    {
        ResolverSettings resolverSettings = new ResolverSettings();
        java.util.Set parsed = new java.util.HashSet();
        while ( ( strict ? xmlStreamReader.nextTag() : nextTag( xmlStreamReader ) ) == XMLStreamConstants.START_ELEMENT )
        {
            if ( checkFieldWithDuplicate( xmlStreamReader, "debug", null, parsed ) )
            {
                resolverSettings.setDebug( getBooleanValue( getTrimmedValue( xmlStreamReader.getElementText() ), "debug", xmlStreamReader ) );
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "localRepositories", null, parsed ) )
            {
                java.util.List localRepositories = new java.util.ArrayList/*<String>*/();
                resolverSettings.setLocalRepositories( localRepositories );
                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
                {
                    if ( "repository".equals( xmlStreamReader.getLocalName() ) )
                    {
                        localRepositories.add( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "new java.util.ArrayList/*<String>*/()" ) ) );
                    }
                    else
                    {
                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
                    }
                }
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "metadataRepositories", null, parsed ) )
            {
                java.util.List metadataRepositories = new java.util.ArrayList/*<String>*/();
                resolverSettings.setMetadataRepositories( metadataRepositories );
                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
                {
                    if ( "repository".equals( xmlStreamReader.getLocalName() ) )
                    {
                        metadataRepositories.add( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "new java.util.ArrayList/*<String>*/()" ) ) );
                    }
                    else
                    {
                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
                    }
                }
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "prefixes", null, parsed ) )
            {
                java.util.List prefixes = new java.util.ArrayList/*<String>*/();
                resolverSettings.setPrefixes( prefixes );
                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
                {
                    if ( "prefix".equals( xmlStreamReader.getLocalName() ) )
                    {
                        prefixes.add( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "new java.util.ArrayList/*<String>*/()" ) ) );
                    }
                    else
                    {
                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
                    }
                }
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "blacklist", null, parsed ) )
            {
                java.util.List blacklist = new java.util.ArrayList/*<Artifact>*/();
                resolverSettings.setBlacklist( blacklist );
                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
                {
                    if ( "artifact".equals( xmlStreamReader.getLocalName() ) )
                    {
                        resolverSettings.addBlacklist( parseArtifact( xmlStreamReader, strict ) );
                    }
                    else
                    {
                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
                    }
                }
            }
            else
            {
                checkUnknownElement( xmlStreamReader, strict );
            }
        }
        return resolverSettings;
    } //-- ResolverSettings parseResolverSettings( XMLStreamReader, boolean )

    /**
     * Method parseStereotype.
     * 
     * @param xmlStreamReader
     * @param strict
     * @throws IOException
     * @throws XMLStreamException
     * @return Stereotype
     */
    private Stereotype parseStereotype( XMLStreamReader xmlStreamReader, boolean strict )
        throws IOException, XMLStreamException
    {
        Stereotype stereotype = new Stereotype();
        java.util.Set parsed = new java.util.HashSet();
        while ( ( strict ? xmlStreamReader.nextTag() : nextTag( xmlStreamReader ) ) == XMLStreamConstants.START_ELEMENT )
        {
            if ( checkFieldWithDuplicate( xmlStreamReader, "type", null, parsed ) )
            {
                stereotype.setType( getTrimmedValue( xmlStreamReader.getElementText() ) );
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "extension", null, parsed ) )
            {
                stereotype.setExtension( getTrimmedValue( xmlStreamReader.getElementText() ) );
            }
            else if ( checkFieldWithDuplicate( xmlStreamReader, "classifier", null, parsed ) )
            {
                stereotype.setClassifier( getTrimmedValue( xmlStreamReader.getElementText() ) );
            }
            else
            {
                checkUnknownElement( xmlStreamReader, strict );
            }
        }
        return stereotype;
    } //-- Stereotype parseStereotype( XMLStreamReader, boolean )

    /**
     * Method read.
     * 
     * @param xmlStreamReader
     * @param strict
     * @throws IOException
     * @throws XMLStreamException
     * @return Configuration
     */
    private Configuration read( XMLStreamReader xmlStreamReader, boolean strict )
        throws IOException, XMLStreamException
    {
        int eventType = xmlStreamReader.getEventType();
        String encoding = null;
        while ( eventType != XMLStreamConstants.END_DOCUMENT )
        {
            if ( eventType == XMLStreamConstants.START_DOCUMENT )
            {
                encoding = xmlStreamReader.getCharacterEncodingScheme();
            }
            if ( eventType == XMLStreamConstants.START_ELEMENT )
            {
                if ( strict && ! "configuration".equals( xmlStreamReader.getLocalName() ) )
                {
                    throw new XMLStreamException( "Expected root element 'configuration' but found '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation(), null );
                }
                Configuration configuration = parseConfiguration( xmlStreamReader, strict );
                configuration.setModelEncoding( encoding );
                resolveReferences( configuration );
                return configuration;
            }
            eventType = xmlStreamReader.next();
        }
        throw new XMLStreamException( "Expected root element 'configuration' but found no element at all: invalid XML document", xmlStreamReader.getLocation(), null );
    } //-- Configuration read( XMLStreamReader, boolean )

    /**
     * Method resolveReferences.
     * 
     * @param value
     */
    private void resolveReferences( Configuration value )
    {
        java.util.Map refs;
    } //-- void resolveReferences( Configuration )

}
